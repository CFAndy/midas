package midas
package passes

import firrtl._
import firrtl.ir._
import firrtl.Mappers._
import firrtl.passes.createMask
import firrtl.passes.MemPortUtils.memPortField
import firrtl.passes.LowerTypes.loweredName
import firrtl.Utils.{one, kind, create_exps, splitRef}
import midas.passes.Utils._

case class MemConf(
  name: String,
  depth: BigInt,
  width: BigInt,
  readers: Seq[String],
  writers: Seq[String],
  readwriters: Seq[String],
  maskGran: BigInt)

object MemConfReader {
  sealed trait ConfField
  case object Name extends ConfField
  case object Depth extends ConfField
  case object Width extends ConfField
  case object Ports extends ConfField
  case object MaskGran extends ConfField
  type ConfFieldMap = Map[ConfField, String]
  // Read a conf file generated by [[firrtl.passes.ReplSeqMems]]
  def apply(conf: java.io.File): Seq[MemConf] = {
    def parse(map: ConfFieldMap, list: List[String]): ConfFieldMap = list match {
      case Nil => map
      case "name" :: value :: tail => parse(map + (Name -> value), tail)
      case "depth" :: value :: tail => parse(map + (Depth -> value), tail)
      case "width" :: value :: tail => parse(map + (Width -> value), tail)
      case "ports" :: value :: tail => parse(map + (Ports -> value), tail)
      case "mask_gran" :: value :: tail => parse(map + (MaskGran -> value), tail)
      case field :: tail => firrtl.Utils.error(s"Unknown field $field")
    }
    io.Source.fromFile(conf).getLines.toSeq map { line =>
      val map = parse(Map[ConfField, String](), (line split " ").toList)
      val ports = map(Ports) split ","
      MemConf(map(Name), BigInt(map(Depth)), BigInt(map(Width)),
        ports filter (_ == "read"),
        ports filter (p => p == "write" || p == "mwrite"),
        ports filter (p => p == "rw" || p == "mrw"),
        map get MaskGran map (BigInt(_)) getOrElse (BigInt(map(Width))))
    }
  }
}

private class SeqMem(info: Info, mem: MemConf) extends DefMemory(
  info,
  mem.name,
  if (mem.maskGran == mem.width) UIntType(IntWidth(mem.width))
  else VectorType(UIntType(IntWidth(mem.maskGran)), (mem.width / mem.maskGran).toInt),
  mem.depth.toInt,
  1, // writeLatency
  1, // readLatency
  mem.readers.indices map (i => s"R$i"),
  mem.writers.indices map (i => s"W$i"),
  mem.readwriters.indices map (i => s"RW$i")) {
  val hasMaskPort = mem.width != mem.maskGran
}

private[passes] class ToSeqMems(conf: java.io.File) extends firrtl.passes.Pass {
  override def name = "[strober] To SeqMems"

  lazy val seqMems = (MemConfReader(conf) map (m => m.name -> m)).toMap

  type Netlist = collection.mutable.HashMap[String, Expression]

  def createMap(e: Expression, isIo: Boolean): (String, Expression) = {
    val (ref, subfield) = splitRef(e)
    val name = loweredName(subfield)
    (if (isIo) name else s"${ref.name}.$name") -> e
  }

  def mapPorts(mem: SeqMem, locs: Netlist, exprs: Netlist, repl: Netlist) {
    mem.readers foreach { r =>
      locs ++= Seq("clk", "addr", "en") map (f => createMap(memPortField(mem, r, f), false))
      (mem.dataType: @unchecked) match {
        case _: UIntType =>
          repl += createMap(memPortField(mem, r, "data"), false)
        case _: VectorType =>
          exprs ++= create_exps(memPortField(mem, r, "data")) map (e => createMap(e, true))
      }
    }
    mem.writers foreach { w =>
      locs ++= Seq("clk", "addr", "en") map (f => createMap(memPortField(mem, w, f), false))
      (mem.dataType: @unchecked) match {
        case _: UIntType =>
          repl ++= Seq("data", "mask") map (f => createMap(memPortField(mem, w, f), false))
        case _: VectorType =>
          locs ++= Seq("data", "mask") map (f => createMap(memPortField(mem, w, f), false))
      }
    }
    mem.readwriters foreach { rw =>
      locs ++= Seq("clk", "addr", "en", "wmode") map (f => createMap(memPortField(mem, rw, f), false))
      (mem.dataType: @unchecked) match {
        case _: UIntType =>
          repl ++= Seq("wdata", "wmask", "rdata") map (f => createMap(memPortField(mem, rw, f), false))
        case _: VectorType =>
          locs ++= Seq("wdata", "wmask") map (f => createMap(memPortField(mem, rw, f), false))
          exprs ++= create_exps(memPortField(mem, rw, "rdata")) map (e => createMap(e, true))
      }
    }
  }

  def setMask(mem: SeqMem) = {
    (mem.writers map (p => Connect(NoInfo, memPortField(mem, p, "mask"), one))) ++
    (mem.readwriters map (p => Connect(NoInfo, memPortField(mem, p, "wmask"), one)))
  }

  def replaceInsts(locs: Netlist, exprs: Netlist, repl: Netlist)(s: Statement): Statement =
    s map replaceInsts(locs, exprs, repl) match {
      case s: WDefInstance => seqMems get s.name match {
        case None => s
        case Some(bb) =>
          val mem = new SeqMem(s.info, bb)
          mapPorts(mem, locs, exprs, repl)
          if (mem.hasMaskPort) mem else Block(mem +: setMask(mem))
      }
      case s => s
    }

  def updateExpr(repl: Netlist)(e: Expression): Expression =
    repl get e.serialize match {
      case Some(ex) => ex
      case None => e map updateExpr(repl)
    }

  def replaceExps(locs: Netlist, exprs: Netlist, repl: Netlist)(s: Statement): Statement =
    s map replaceExps(locs, exprs, repl) match {
      case s: Connect => locs get s.loc.serialize match {
        case Some(e) => Block(create_exps(e) map (ex =>
          Connect(s.info, ex, WRef(loweredName(splitRef(ex)._2)))
        ))
        case None => exprs get s.loc.serialize match {
          case Some(e) => s.copy(expr=e)
          case None => s map updateExpr(repl)
        }
      }
      case s => s
    }

  def onMod(m: DefModule): DefModule = {
    val (locs, exprs, repl) = (new Netlist, new Netlist, new Netlist)
    val mx = m map replaceInsts(locs, exprs, repl)
    if (locs.isEmpty && exprs.isEmpty && repl.isEmpty) mx
    else mx map replaceExps(locs, exprs, repl)
  }

  def run(c: Circuit) = c.copy(modules =
    c.modules filterNot (seqMems contains _.name) map onMod)
}

